__title__ = "laser cut box"
__author__ = "Greg Harley"
__version__ = "01.00"
__date__ = "12/31/20"

__Comment__ = "This macro creates a sketch of a laser cut box which can then be save to a DXF file."

from math import floor

from PySide import QtCore, QtGui
from FreeCAD import Gui
import Part, PartDesign, Sketcher

App = FreeCAD

# Indexes for geoid
START = 1
END = 2
ORIGIN = -1

# Indexes for planes
XY_PLANE = 3
XZ_PLANE = XY_PLANE + 1
YZ_PLANE = XZ_PLANE + 1

# Indexes for box sides
TOP = 0
RIGHT = 1
BOTTOM = 2
LEFT = 3


class Box:
    def __init__(self):
        if not App.ActiveDocument:
            App.newDocument()

        self.dialog = None
        self.worksheet = None
        self.box_type = 0

        self.init_dialog()

        self.dialog.show()
        self.dialog.exec_()

    def init_dialog(self):
        self.dialog = Gui.PySideUic.loadUi("C:/Users/gharley/AppData/Roaming/FreeCAD/Macro/Macro_LaserCutBox.ui")
        self.dialog.setWindowTitle("Laser cut box")

        QtCore.QObject.connect(self.dialog.buttonBox, QtCore.SIGNAL("accepted()"), self.init_sheet)

    def init_sheet(self):
        self.worksheet = App.ActiveDocument.addObject("Spreadsheet::Sheet", "Parameters")
        set_cell = self.worksheet.set

        def column_a(idx):
            return 'A' + str(idx)

        def column_b(idx):
            return 'B' + str(idx)

        self.worksheet.setColumnWidth('A', 150)

        index = 0
        for obj in self.dialog.findChildren(QtGui.QLabel):
            index += 1
            col_a = column_a(index)
            col_b = column_b(index)

            buddy = obj.buddy()
            if not (buddy is None):
                if isinstance(buddy, QtGui.QComboBox):
                    self.box_type = buddy.currentIndex()
                    index -= 1
                else:
                    set_cell(col_a, obj.text())
                    set_cell(col_b, buddy.text())
                    self.worksheet.setAlias(col_b, buddy.objectName())
            else:
                self.worksheet.setStyle(col_a, 'bold')
                self.worksheet.setAlignment(col_a, 'center|vcenter')
                self.worksheet.mergeCells(col_a + ':' + col_b)
                set_cell(col_a, obj.text())

        index += 1
        col_a = column_a(index)
        self.worksheet.setStyle(col_a, 'bold')
        self.worksheet.setAlignment(col_a, 'center|vcenter')
        self.worksheet.mergeCells(col_a + ':' + column_b(index))
        set_cell(col_a, 'Calculated Values DO NOT EDIT')

        def set_calc(index, label, alias, formula):
            col_a = column_a(index)
            col_b = column_b(index)
            set_cell(col_a, label)
            set_cell(col_b, formula)
            self.worksheet.setAlias(col_b, alias)

        index += 1
        set_calc(index, 'Side tab gap', 'sideGap',
                 '=(width - offsetH * 2 - tabWidth * numTabsLength) / (numTabsLength - 1)')

        index += 1
        set_calc(index, 'End tab gap', 'endGap',
                 '=(depth - offsetH * 2 - tabWidth * numTabsDepth) / (numTabsDepth - 1)')

        index += 1
        set_calc(index, 'Height tab gap', 'heightGap',
                 '=(height - offsetV * 2 - tabWidth * numTabsHeight) / (numTabsHeight - 1)')

        App.ActiveDocument.recompute(None, True, True)

        self.build_long_side()
        # self.build_short_side()

    def _build_side(self, sketch_name, width_alias, height_alias, offset_alias, plane_index, tab_func):
        sheet = self.worksheet
        sheet_prefix = self.get_sheet_expression_prefix()

        body = App.ActiveDocument.addObject('PartDesign::Body', sketch_name)
        sketch = App.ActiveDocument.addObject('Sketcher::SketchObject', sketch_name + "Sketch")
        body.addObject(sketch)

        # This looks good but screws up DXF export
        # sketch.Support = body.Origin.OriginFeatures[plane_index]
        # sketch.MapMode = 'FlatFace'

        width = sheet.get(sheet.getCellFromAlias(width_alias))
        height = sheet.get(sheet.getCellFromAlias(height_alias))
        thickness = sheet.get(sheet.getCellFromAlias('thickness'))
        offset = sheet.get(sheet.getCellFromAlias(offset_alias))

        if self.box_type == 0:
            thickness_multiplier = 3
        elif self.box_type == 1:
            thickness_multiplier = 2
        else:
            thickness_multiplier = 1

        box = self.draw_box(sketch, width * 2, height + thickness * thickness_multiplier,
                            '{0}{1} + {0}thickness * 2'.format(sheet_prefix, width_alias),
                            '{0}{1} + {0}thickness * {2}'.format(sheet_prefix, height_alias, thickness_multiplier))
        sketch.addConstraint(Sketcher.Constraint('Symmetric', box[TOP], START, box[BOTTOM], START, ORIGIN, START))

        if self.box_type != 2:
            tab = tab_func(sketch)[0]

            constraint = sketch.addConstraint(Sketcher.Constraint('DistanceX', box[TOP], START, tab[TOP], START, offset))
            sketch.setExpression("Constraints[{0}]".format(str(constraint)), '{0}{1}'.format(sheet_prefix, offset_alias))

            constraint = sketch.addConstraint(Sketcher.Constraint('DistanceY', tab[TOP], START, box[TOP], START, thickness))
            sketch.setExpression("Constraints[{0}]".format(str(constraint)), '{0}thickness'.format(sheet_prefix))

        if self.box_type != 1:
            lines = self.draw_edge_tabs(sketch, 'numTabsLength', 'tabWidth', 'offsetH', 'sideGap', False)
            sketch.addConstraint(Sketcher.Constraint('Coincident', box[LEFT], START, lines[0], START))
            sketch.addConstraint(Sketcher.Constraint('Coincident', box[RIGHT], END, lines[len(lines)-1], END))
            sketch.delGeometry(box[BOTTOM])

        App.ActiveDocument.recompute(None, True, True)
        Gui.ActiveDocument.ActiveView.fitAll()

    def build_long_side(self):
        self._build_side("BoxSide", "width", "height", "offsetH", XZ_PLANE, self.draw_side_tabs)

    def build_short_side(self):
        self._build_side("BoxEnd", "depth", "height", "offsetH", YZ_PLANE, self.draw_end_tabs)

    def draw_box(self, sketch, width, height, expression_h, expression_v):
        lower_left, upper_left, lower_right, upper_right = self.get_vectors(width, height)

        top = sketch.addGeometry(Part.LineSegment(upper_left, upper_right), False)
        right = sketch.addGeometry(Part.LineSegment(upper_right, lower_right), False)
        bottom = sketch.addGeometry(Part.LineSegment(lower_right, lower_left), False)
        left = sketch.addGeometry(Part.LineSegment(lower_left, upper_left), False)

        sketch.addConstraint(Sketcher.Constraint('Horizontal', top))
        sketch.addConstraint(Sketcher.Constraint('Horizontal', bottom))
        sketch.addConstraint(Sketcher.Constraint('Vertical', left))
        sketch.addConstraint(Sketcher.Constraint('Vertical', right))

        sketch.addConstraint(Sketcher.Constraint('Coincident', top, END, right, START))
        sketch.addConstraint(Sketcher.Constraint('Coincident', right, END, bottom, START))
        sketch.addConstraint(Sketcher.Constraint('Coincident', bottom, END, left, START))
        sketch.addConstraint(Sketcher.Constraint('Coincident', left, END, top, START))

        constraint = sketch.addConstraint(Sketcher.Constraint('DistanceX', top, width))
        sketch.setExpression("Constraints[{0}]".format(str(constraint)), expression_h)

        constraint = sketch.addConstraint(Sketcher.Constraint('DistanceY', left, height))
        sketch.setExpression("Constraints[{0}]".format(str(constraint)), expression_v)

        return [top, right, bottom, left]

    def _draw_tabs(self, sketch, num_tabs, tab_width, thickness, gap, expression_width, expression_thickness, expression_gap):
        tabs = []
        for idx in range(0, num_tabs):
            tab = self.draw_box(sketch, tab_width, thickness, expression_width, expression_thickness)
            tabs.append(tab)

            if idx == 0:
                first = tab
            else:
                constraint = sketch.addConstraint(Sketcher.Constraint('DistanceX', first[TOP], END, tab[TOP], START, gap * idx + tab_width * (idx - 1)))
                sketch.setExpression("Constraints[{0}]".format(str(constraint)), expression_gap.format(idx))

                sketch.addConstraint(Sketcher.Constraint('DistanceY', first[TOP], END, tab[TOP], START, 0))

        return tabs

    def draw_tabs(self, sketch, num_tabs, gap_alias):
        sheet = self.worksheet
        sheet_prefix = self.get_sheet_expression_prefix()

        tab_width = sheet.get(sheet.getCellFromAlias('tabWidth'))
        thickness = sheet.get(sheet.getCellFromAlias('thickness'))
        gap = sheet.get(sheet.getCellFromAlias(gap_alias))

        return self._draw_tabs(sketch, num_tabs, tab_width, thickness, gap,
                               '{0}tabWidth'.format(sheet_prefix),
                               '{0}thickness'.format(sheet_prefix),
                               '{0}{1} * {2} + {0}tabWidth * ({2} - 1)'.format(sheet_prefix, gap_alias, '{0}'))

    def draw_edge_tabs(self, sketch, num_tabs_alias, width_alias, offset_alias, gap_alias, is_inset=False):
        sheet = self.worksheet
        sheet_prefix = self.get_sheet_expression_prefix()

        num_tabs = sheet.get(sheet.getCellFromAlias(num_tabs_alias))
        width = sheet.get(sheet.getCellFromAlias(width_alias))
        offset = sheet.get(sheet.getCellFromAlias(offset_alias))
        gap = sheet.get(sheet.getCellFromAlias(gap_alias))
        thickness = sheet.get(sheet.getCellFromAlias('thickness'))

        lines = []

        offset_length = App.Vector(offset, 0)
        horizontal_length = App.Vector(width, 0)
        horizontal_line_index = -1
        if is_inset:
            vertical_length = App.Vector(0, thickness)
        else:
            vertical_length = App.Vector(0, -thickness)

        gap_length = App.Vector(gap, 0)

        start = App.Vector(0, 0)
        gap_line_index = -1
        offset_line_index = -1
        vertical_line_index = -1
        line_index = -1

        def add_line(start_point, end_offset, previous, is_horizontal=False, is_vertical=False):
            new_line = Part.LineSegment(start_point, start_point + end_offset)
            index = sketch.addGeometry(new_line, False)

            if previous != -1:
                sketch.addConstraint(Sketcher.Constraint('Coincident', previous, END, index, START))
            if is_horizontal:
                sketch.addConstraint(Sketcher.Constraint('Horizontal', index))
            elif is_vertical:
                sketch.addConstraint(Sketcher.Constraint('Vertical', index))

            lines.append(index)

            return new_line.EndPoint, index, new_line

        for idx in range(0, num_tabs):
            if idx == 0:
                start, line_index, line = add_line(start, offset_length, line_index, True)

                if offset_line_index == -1:
                    offset_line_index = line_index
                    constraint = sketch.addConstraint(Sketcher.Constraint('DistanceX', offset_line_index, offset))
                    sketch.setExpression('Constraints[{0}]'.format(str(constraint)), "{0}{1}".format(sheet_prefix, offset_alias))
            else:
                start, line_index, line = add_line(start, gap_length, line_index, True)

                if gap_line_index == -1:
                    gap_line_index = line_index
                    constraint = sketch.addConstraint(Sketcher.Constraint('DistanceX', gap_line_index, gap))
                    sketch.setExpression('Constraints[{0}]'.format(str(constraint)), '{0}{1}'.format(sheet_prefix, gap_alias))
                else:
                    sketch.addConstraint(Sketcher.Constraint('Equal', gap_line_index, line_index))

            start, line_index, line = add_line(start, vertical_length, line_index, False, True)

            if idx == 0:
                vertical_line_index = line_index
                value = thickness
                expression = '{0}thickness'.format(sheet_prefix)
                if not is_inset:
                    value = -value
                    expression = '-' + expression

                constraint = sketch.addConstraint(Sketcher.Constraint('DistanceY', vertical_line_index, value))
                sketch.setExpression('Constraints[{0}]'.format(str(constraint)), expression)
            else:
                sketch.addConstraint(Sketcher.Constraint('Equal', vertical_line_index, line_index))

            start, line_index, line = add_line(start, horizontal_length, line_index, True)

            if idx == 0:
                horizontal_line_index = line_index
                constraint = sketch.addConstraint(Sketcher.Constraint('DistanceX', horizontal_line_index, width))
                sketch.setExpression('Constraints[{0}]'.format(str(constraint)), '{0}{1}'.format(sheet_prefix, width_alias))
            else:
                sketch.addConstraint(Sketcher.Constraint('Equal', horizontal_line_index, line_index))

            start, line_index, line = add_line(start, -vertical_length, line_index, False, True)
            sketch.addConstraint(Sketcher.Constraint('Equal', vertical_line_index, line_index))

        add_line(start, offset_length, line_index, True)

        return lines

    def draw_end_tabs(self, sketch):
        sheet = self.worksheet
        num_tabs = floor(sheet.get(sheet.getCellFromAlias('numTabsDepth')))

        return self.draw_tabs(sketch, num_tabs, "endGap")

    def draw_side_tabs(self, sketch):
        sheet = self.worksheet
        num_tabs = floor(sheet.get(sheet.getCellFromAlias('numTabsLength')))

        return self.draw_tabs(sketch, num_tabs, "sideGap")

    def get_sheet_expression_prefix(self):
        return '<<' + self.worksheet.Name + '>>.'

    @staticmethod
    def get_vectors(width, height, offset_h = 0, offset_v = 0):
        lower_left = App.Vector(0 + offset_h, 0 + offset_v, 0)
        upper_left = App.Vector(0 + offset_h, height + offset_v, 0)
        lower_right = App.Vector(width + offset_h, 0 + offset_v, 0)
        upper_right = App.Vector(width + offset_h, height + offset_v, 0)

        return lower_left, upper_left, lower_right, upper_right


Box()
