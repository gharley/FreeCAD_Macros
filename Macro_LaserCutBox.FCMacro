__title__ = "laser cut box"
__author__ = "Greg Harley"
__version__ = "01.00"
__date__ = "12/31/20"

__Comment__ = "This macro creates a sketch of a laser cut box which can then be save to a DXF file."

from math import floor
from typing import Optional

from PySide import QtCore, QtGui
from FreeCAD import Gui
import Part, PartDesign, Sketcher

import Macro_LaserCutBox_rc

App = FreeCAD

# Indexes for geoid
START = 1
END = 2
ORIGIN = -1

# Indexes for planes
XY_PLANE = 3
XZ_PLANE = XY_PLANE + 1
YZ_PLANE = XZ_PLANE + 1

# Indexes for box sides
TOP = 0
RIGHT = 1
BOTTOM = 2
LEFT = 3


class Box:
    def __init__(self):
        if not App.ActiveDocument:
            App.newDocument()

        self.macro_dir = App.getUserMacroDir()

        self.dialog = Optional[QtGui.QWidget]
        self.image = Optional[QtGui.QLabel]
        self.worksheet = None
        self.box_type = 0

        self.init_dialog()

        self.dialog.show()
        self.dialog.exec_()

    def init_dialog(self):
        self.dialog = Gui.PySideUic.loadUi('{0}Macro_LaserCutBox.ui'.format(self.macro_dir))
        self.dialog.setWindowTitle("Laser cut box")

        self.image = self.dialog.findChild(QtGui.QLabel, 'image')
        # pixmap = QtGui.QPixmap(":/images/end_all.png")
        pixmap = QtGui.QPixmap(self.macro_dir + "end_all.png")
        # pixmap = QtGui.QPixmap(':/images/end_all.png')
        self.image.setPixmap(pixmap.scaledToHeight(self.image.height()))
        # self.image.setText('pixmap')
        # App.Console.PrintMessage(QtCore.QFile.exists(self.macro_dir + "end_all.png"))
        # App.Console.PrintMessage(pixmap.isNull())

        QtCore.QObject.connect(self.dialog.buttonBox, QtCore.SIGNAL("accepted()"), self.build_geometry)

    def init_sheet(self):
        self.worksheet = App.ActiveDocument.addObject("Spreadsheet::Sheet", "Parameters")
        set_cell = self.worksheet.set

        def column_a(idx):
            return 'A' + str(idx)

        def column_b(idx):
            return 'B' + str(idx)

        self.worksheet.setColumnWidth('A', 150)

        index = 0
        for obj in self.dialog.findChildren(QtGui.QLabel):
            index += 1
            col_a = column_a(index)
            col_b = column_b(index)

            buddy = obj.buddy()
            if buddy is not None:
                if isinstance(buddy, QtGui.QComboBox):
                    self.box_type = buddy.currentIndex()
                    index -= 1
                else:
                    set_cell(col_a, obj.text())
                    set_cell(col_b, buddy.text())
                    self.worksheet.setAlias(col_b, buddy.objectName())
            else:
                self.worksheet.setStyle(col_a, 'bold')
                self.worksheet.setAlignment(col_a, 'center|vcenter')
                self.worksheet.mergeCells(col_a + ':' + col_b)
                set_cell(col_a, obj.text())

        App.ActiveDocument.recompute(None, True, True)

        if self.worksheet.bottomThickness == 0:
            self.worksheet.set(self.worksheet.getCellFromAlias('bottomThickness'), str(self.worksheet.thickness))

        if self.worksheet.lidThickness == 0:
            self.worksheet.set(self.worksheet.getCellFromAlias('lidThickness'), str(self.worksheet.thickness))

        index += 1
        col_a = column_a(index)
        self.worksheet.setStyle(col_a, 'bold')
        self.worksheet.setAlignment(col_a, 'center|vcenter')
        self.worksheet.mergeCells(col_a + ':' + column_b(index))
        set_cell(col_a, 'Calculated Values DO NOT EDIT')

        def set_calc(label, alias, formula):
            _col_b = column_b(index)
            set_cell(column_a(index), label)
            set_cell(_col_b, formula)
            self.worksheet.setAlias(_col_b, alias)

        index += 1
        set_calc('Side tab gap', 'sideGap', '=(width - offsetH * 2 - tabWidth * numTabsLength) / (numTabsLength - 1)')

        index += 1
        set_calc('End tab gap', 'endGap', '=(depth - offsetH * 2 - tabWidth * numTabsDepth) / (numTabsDepth - 1)')

        index += 1

        gap_mask = '=(({0}) - offsetV * 2 - tabWidth * numTabsHeight) / (numTabsHeight - 1)'
        if self.box_type == 0:
            set_calc('Height tab gap', 'heightGap', gap_mask.format('height + lidThickness + bottomThickness * 2'))
        elif self.box_type == 1:
            set_calc('Height tab gap', 'heightGap', gap_mask.format('height + lidThickness + bottomThickness'))
        else:
            set_calc('Height tab gap', 'heightGap', gap_mask.format('height + bottomThickness'))

        App.ActiveDocument.recompute(None, True, True)

    def build_geometry(self):
        self.init_sheet()

        if self.dialog.chkSide.isChecked():
            self.build_long_side()

        if self.dialog.chkEnd.isChecked():
            self.build_short_side()

        if self.dialog.chkBottom.isChecked():
            self.build_bottom()

    def _build_side(self, sketch_name, width_alias, num_tabs_alias, gap_alias, tab_func):
        sheet = self.worksheet
        sheet_prefix = self.get_sheet_expression_prefix()

        sketch = self._add_sketch(sketch_name)

        thickness = sheet.thickness
        bottom_thickness = sheet.bottomThickness
        lid_thickness = sheet.lidThickness
        width = sheet.get(sheet.getCellFromAlias(width_alias))
        actual_width = width + thickness
        width_expression = '{0}{1} + {0}thickness'.format(sheet_prefix, width_alias)
        offset = sheet.offsetH
        height = sheet.height

        if self.box_type == 0:
            actual_height = height + lid_thickness + bottom_thickness * 2
            height_expression = '{0}height + {0}lidThickness + {0}bottomThickness * 2'.format(sheet_prefix)
        elif self.box_type == 1:
            actual_height = height + lid_thickness + bottom_thickness
            height_expression = '{0}height + {0}lidThickness + {0}bottomThickness'.format(sheet_prefix)
        else:
            actual_height = height + bottom_thickness
            height_expression = '{0}height + {0}bottomThickness'.format(sheet_prefix)

        lower_left, upper_left, lower_right, upper_right = self.get_vectors(actual_width, actual_height)

        box = [[sketch.addGeometry(Part.LineSegment(upper_left, upper_right), False)]]

        if self.box_type != 2:
            tab = tab_func(sketch)[-1]

            constraint = sketch.addConstraint(Sketcher.Constraint('DistanceX', tab[TOP], END, box[TOP][-1], END, offset))
            sketch.setExpression("Constraints[{0}]".format(str(constraint)), '{0}offsetH'.format(sheet_prefix))

            constraint = sketch.addConstraint(Sketcher.Constraint('DistanceY', tab[TOP], START, box[TOP][0], START, lid_thickness))
            sketch.setExpression("Constraints[{0}]".format(str(constraint)), '{0}lidThickness'.format(sheet_prefix))

        lines = self.draw_edge_tabs(sketch, 'numTabsHeight', 'tabWidth', 'offsetV', 'heightGap', True, True)
        box.append(lines)

        if self.box_type != 1:
            lines = self.draw_edge_tabs(sketch, num_tabs_alias, 'tabWidth', 'offsetH', gap_alias, True, False)
        else:
            lines = [sketch.addGeometry(Part.LineSegment(lower_left, lower_right), False)]

        box.append(lines)

        lines = self.draw_edge_tabs(sketch, 'numTabsHeight', 'tabWidth', 'offsetV', 'heightGap', True, True)
        box.append(lines)

        sketch.addConstraint(Sketcher.Constraint('Horizontal', box[TOP][0]))
        constraint = sketch.addConstraint(Sketcher.Constraint('DistanceX', box[TOP][0], actual_width))
        sketch.setExpression("Constraints[{0}]".format(str(constraint)), width_expression)

        if self.box_type != 1:
            constraint = sketch.addConstraint(Sketcher.Constraint('DistanceX', box[BOTTOM][0], START, box[BOTTOM][-1], END, actual_width))
            sketch.setExpression("Constraints[{0}]".format(str(constraint)), width_expression)

        constraint = sketch.addConstraint(Sketcher.Constraint('DistanceY', box[LEFT][0], START, box[LEFT][-1], END, actual_height))
        sketch.setExpression("Constraints[{0}]".format(str(constraint)), height_expression)
        constraint = sketch.addConstraint(Sketcher.Constraint('DistanceY', box[RIGHT][0], START, box[RIGHT][-1], END, actual_height))
        sketch.setExpression("Constraints[{0}]".format(str(constraint)), height_expression)

        self._constrain_sides(sketch, box, upper_left, upper_right, lower_left)
        # sketch.movePoint(box[TOP], START, upper_left)
        # sketch.movePoint(box[RIGHT][-1], END, upper_right)
        # sketch.movePoint(box[LEFT][-1], END, upper_left)
        # sketch.movePoint(box[BOTTOM][0], START, lower_left)
        # sketch.addConstraint(Sketcher.Constraint('Coincident', box[TOP], START, box[LEFT][-1], END))
        # sketch.addConstraint(Sketcher.Constraint('Coincident', box[TOP], END, box[RIGHT][-1], END))
        # sketch.addConstraint(Sketcher.Constraint('Coincident', box[LEFT][0], START, box[BOTTOM][0], START))

        if self.box_type == 1:
            sketch.addConstraint(Sketcher.Constraint('Coincident', box[BOTTOM][-1], END, box[RIGHT][0], START))

        sketch.addConstraint(Sketcher.Constraint('Symmetric', box[TOP][0], START, box[RIGHT][0], START, ORIGIN, START))

        App.ActiveDocument.recompute(None, True, True)
        Gui.ActiveDocument.ActiveView.fitAll()

    def build_bottom(self):
        sheet = self.worksheet
        sheet_prefix = self.get_sheet_expression_prefix()

        sketch = self._add_sketch('BoxBottom')

        width_alias = 'width'
        width = sheet.width + sheet.thickness
        width_expression = '{0}{1} + {0}thickness'.format(sheet_prefix, width_alias)
        depth_alias = 'depth'
        depth = sheet.depth + sheet.thickness
        depth_expression = '{0}{1} + {0}thickness'.format(sheet_prefix, depth_alias)
        tabs_width_alias = 'numTabsLength'
        tabs_depth_alias = 'numTabsDepth'

        lower_left, upper_left, lower_right, upper_right = self.get_vectors(width, depth)

        box = [self.draw_edge_tabs(sketch, tabs_width_alias, 'tabWidth', 'offsetH', 'sideGap', True, False),
               self.draw_edge_tabs(sketch, tabs_depth_alias, 'tabWidth', 'offsetV', 'endGap', True, True),
               self.draw_edge_tabs(sketch, tabs_width_alias, 'tabWidth', 'offsetH', 'sideGap', False, False),
               self.draw_edge_tabs(sketch, tabs_depth_alias, 'tabWidth', 'offsetV', 'endGap', False, True)]

        constraint = sketch.addConstraint(Sketcher.Constraint('DistanceX', box[TOP][0], START, box[TOP][-1], END, width))
        sketch.setExpression("Constraints[{0}]".format(str(constraint)), width_expression)
        constraint = sketch.addConstraint(Sketcher.Constraint('DistanceX', box[BOTTOM][0], START, box[BOTTOM][-1], END, width))
        sketch.setExpression("Constraints[{0}]".format(str(constraint)), width_expression)

        constraint = sketch.addConstraint(Sketcher.Constraint('DistanceY', box[LEFT][0], START, box[LEFT][-1], END, depth))
        sketch.setExpression("Constraints[{0}]".format(str(constraint)), depth_expression)
        constraint = sketch.addConstraint(Sketcher.Constraint('DistanceY', box[RIGHT][0], START, box[RIGHT][-1], END, depth))
        sketch.setExpression("Constraints[{0}]".format(str(constraint)), depth_expression)

        self._constrain_sides(sketch, box, upper_left, upper_right, lower_left)
        # sketch.addConstraint(Sketcher.Constraint('Coincident', box[TOP][0], START, box[LEFT][0], START))
        # sketch.addConstraint(Sketcher.Constraint('Coincident', box[RIGHT][0], START, box[TOP][-1], END))
        # sketch.addConstraint(Sketcher.Constraint('Coincident', box[BOTTOM][0], START, box[LEFT][-1], END))
        # sketch.addConstraint(Sketcher.Constraint('Coincident', box[BOTTOM][-1], END, box[RIGHT][-1], END))

        sketch.addConstraint(Sketcher.Constraint('Symmetric', box[TOP][0], START, box[RIGHT][-1], END, ORIGIN, START))

        App.ActiveDocument.recompute(None, True, True)
        Gui.ActiveDocument.ActiveView.fitAll()

    def build_long_side(self):
        self._build_side('BoxSide', 'width', 'numTabsLength', 'sideGap', self.draw_side_slots)

    def build_short_side(self):
        self._build_side('BoxEnd', 'depth', 'numTabsDepth', 'endGap', self.draw_end_slots)

    def draw_slot(self, sketch, width, height, expression_h, expression_v):
        lower_left, upper_left, lower_right, upper_right = self.get_vectors(width, height)

        top = sketch.addGeometry(Part.LineSegment(upper_left, upper_right), False)
        right = sketch.addGeometry(Part.LineSegment(upper_right, lower_right), False)
        bottom = sketch.addGeometry(Part.LineSegment(lower_right, lower_left), False)
        left = sketch.addGeometry(Part.LineSegment(lower_left, upper_left), False)

        sketch.addConstraint(Sketcher.Constraint('Horizontal', top))
        sketch.addConstraint(Sketcher.Constraint('Vertical', left))
        sketch.addConstraint(Sketcher.Constraint('Vertical', right))

        sketch.addConstraint(Sketcher.Constraint('Equal', left, right))

        constraint = sketch.addConstraint(Sketcher.Constraint('DistanceX', top, width))
        sketch.setExpression("Constraints[{0}]".format(str(constraint)), expression_h)

        constraint = sketch.addConstraint(Sketcher.Constraint('DistanceY', left, height))
        sketch.setExpression("Constraints[{0}]".format(str(constraint)), expression_v)

        sketch.addConstraint(Sketcher.Constraint('Coincident', top, END, right, START))
        sketch.addConstraint(Sketcher.Constraint('Coincident', right, END, bottom, START))
        sketch.addConstraint(Sketcher.Constraint('Coincident', bottom, END, left, START))
        sketch.addConstraint(Sketcher.Constraint('Coincident', left, END, top, START))

        return [top, right, bottom, left]

    def _draw_slots(self, sketch, num_tabs, gap, expression_gap):
        tabs = []
        first = []
        tab_width = self.worksheet.tabWidth
        expression_width = '{0}tabWidth'.format(self.get_sheet_expression_prefix())
        bottom_thickness = self.worksheet.bottomThickness
        expression_thickness = '{0}bottomThickness'.format(self.get_sheet_expression_prefix())

        for idx in range(0, num_tabs):
            tab = self.draw_slot(sketch, tab_width, bottom_thickness, expression_width, expression_thickness)
            tabs.append(tab)

            if idx == 0:
                first = tab
            else:
                constraint = sketch.addConstraint(Sketcher.Constraint('DistanceX', first[TOP], END, tab[TOP], START, gap * idx + tab_width * (idx - 1)))
                sketch.setExpression("Constraints[{0}]".format(str(constraint)), expression_gap.format(idx))

                sketch.addConstraint(Sketcher.Constraint('DistanceY', first[TOP], END, tab[TOP], START, 0))

        return tabs

    def draw_slots(self, sketch, num_tabs, gap_alias):
        sheet = self.worksheet
        sheet_prefix = self.get_sheet_expression_prefix()

        gap = sheet.get(sheet.getCellFromAlias(gap_alias))

        return self._draw_slots(sketch, num_tabs, gap, '{0}{1} * {2} + {0}tabWidth * ({2} - 1)'.format(sheet_prefix, gap_alias, '{0}'))

    def draw_end_slots(self, sketch):
        sheet = self.worksheet
        num_tabs = floor(sheet.get(sheet.getCellFromAlias('numTabsDepth')))

        return self.draw_slots(sketch, num_tabs, "endGap")

    def draw_side_slots(self, sketch):
        sheet = self.worksheet
        num_tabs = floor(sheet.get(sheet.getCellFromAlias('numTabsLength')))

        return self.draw_slots(sketch, num_tabs, "sideGap")

    def draw_edge_tabs(self, sketch, num_tabs_alias, width_alias, offset_alias, gap_alias, is_inset=True, is_vertical=False):
        sheet = self.worksheet
        sheet_prefix = self.get_sheet_expression_prefix()

        num_tabs = sheet.get(sheet.getCellFromAlias(num_tabs_alias))
        width = sheet.get(sheet.getCellFromAlias(width_alias))
        offset = sheet.get(sheet.getCellFromAlias(offset_alias))
        gap = sheet.get(sheet.getCellFromAlias(gap_alias))

        lines = []

        start = App.Vector(0, 0)

        if is_vertical:
            thickness = sheet.thickness
            offset_length = App.Vector(0, offset)
            gap_length = App.Vector(0, gap)
            horizontal_length = App.Vector(0, width)
            vertical_length = App.Vector(thickness, 0)
        else:
            thickness = sheet.bottomThickness
            offset_length = App.Vector(offset, 0)  # + App.Vector(sheet.thickness, 0)
            gap_length = App.Vector(gap, 0)
            horizontal_length = App.Vector(width, 0)
            vertical_length = App.Vector(0, thickness)

        if not is_inset:
            vertical_length = -vertical_length

        gap_line_index = -1
        horizontal_line_index = -1
        offset_line_index = -1
        vertical_line_index = -1
        line_index = -1

        def add_line(start_point, end_offset, previous):
            new_line = Part.LineSegment(start_point, start_point + end_offset)
            index = sketch.addGeometry(new_line, False)

            if previous != -1:
                sketch.addConstraint(Sketcher.Constraint('Coincident', previous, END, index, START))
                sketch.addConstraint(Sketcher.Constraint('Perpendicular', previous, index))

            lines.append(index)

            return new_line.EndPoint, index, new_line

        for idx in range(0, num_tabs):
            if idx == 0:
                start, line_index, line = add_line(start, offset_length, line_index)

                if offset_line_index == -1:
                    offset_line_index = line_index
                    if is_vertical:
                        sketch.addConstraint(Sketcher.Constraint('Vertical', offset_line_index))
                    else:
                        sketch.addConstraint(Sketcher.Constraint('Horizontal', offset_line_index))
            else:
                start, line_index, line = add_line(start, gap_length, line_index)

                if gap_line_index == -1:
                    gap_line_index = line_index
                else:
                    sketch.addConstraint(Sketcher.Constraint('Equal', gap_line_index, line_index))

            start, line_index, line = add_line(start, vertical_length, line_index)

            if idx == 0:
                vertical_line_index = line_index
            else:
                sketch.addConstraint(Sketcher.Constraint('Equal', vertical_line_index, line_index))

            start, line_index, line = add_line(start, horizontal_length, line_index)

            if idx == 0:
                horizontal_line_index = line_index
            else:
                sketch.addConstraint(Sketcher.Constraint('Equal', horizontal_line_index, line_index))

            start, line_index, line = add_line(start, -vertical_length, line_index)
            sketch.addConstraint(Sketcher.Constraint('Equal', vertical_line_index, line_index))

        add_line(start, offset_length, line_index)

        value = thickness
        if is_vertical:
            thickness_expression = '{0}thickness'.format(sheet_prefix)
            offset_expression = '{0}{1}'.format(sheet_prefix, offset_alias)
        else:
            thickness_expression = '{0}bottomThickness'.format(sheet_prefix)
            offset_expression = '{0}{1} + {0}thickness'.format(sheet_prefix, offset_alias)

        if not is_inset:
            value = -value
            thickness_expression = '-' + thickness_expression

        if is_vertical:
            constraint_t = sketch.addConstraint(Sketcher.Constraint('DistanceX', vertical_line_index, value))
            constraint_d = sketch.addConstraint(Sketcher.Constraint('DistanceY', offset_line_index, offset))
            constraint_g = sketch.addConstraint(Sketcher.Constraint('DistanceY', gap_line_index, gap))
            constraint_h = sketch.addConstraint(Sketcher.Constraint('DistanceY', horizontal_line_index, width))
        else:
            constraint_t = sketch.addConstraint(Sketcher.Constraint('DistanceY', vertical_line_index, value))
            constraint_d = sketch.addConstraint(Sketcher.Constraint('DistanceX', offset_line_index, offset))
            constraint_g = sketch.addConstraint(Sketcher.Constraint('DistanceX', gap_line_index, gap))
            constraint_h = sketch.addConstraint(Sketcher.Constraint('DistanceX', horizontal_line_index, width))

        sketch.setExpression('Constraints[{0}]'.format(str(constraint_d)), offset_expression)
        sketch.setExpression('Constraints[{0}]'.format(str(constraint_g)), '{0}{1}'.format(sheet_prefix, gap_alias))
        sketch.setExpression('Constraints[{0}]'.format(str(constraint_t)), thickness_expression)
        sketch.setExpression('Constraints[{0}]'.format(str(constraint_h)), '{0}{1}'.format(sheet_prefix, width_alias))

        return lines

# Helper methods
    def get_sheet_expression_prefix(self):
        return '<<' + self.worksheet.Name + '>>.'

    @staticmethod
    def _add_sketch(sketch_name):
        body = App.ActiveDocument.addObject('PartDesign::Body', sketch_name)
        sketch = App.ActiveDocument.addObject('Sketcher::SketchObject', sketch_name + 'Sketch')
        body.addObject(sketch)

        return sketch

    @staticmethod
    def _constrain_sides(sketch, box, upper_left, upper_right, lower_left):
        sketch.movePoint(box[TOP][0], START, upper_left)
        sketch.movePoint(box[RIGHT][-1], END, upper_right)
        sketch.movePoint(box[LEFT][-1], END, upper_left)
        sketch.movePoint(box[BOTTOM][0], START, lower_left)

        sketch.addConstraint(Sketcher.Constraint('Coincident', box[TOP][0], START, box[LEFT][-1], END))
        sketch.addConstraint(Sketcher.Constraint('Coincident', box[TOP][-1], END, box[RIGHT][-1], END))
        sketch.addConstraint(Sketcher.Constraint('Coincident', box[LEFT][0], START, box[BOTTOM][0], START))

    @staticmethod
    def get_vectors(width, height, offset_h = 0, offset_v = 0):
        lower_left = App.Vector(0 + offset_h, 0 + offset_v, 0)
        upper_left = App.Vector(0 + offset_h, height + offset_v, 0)
        lower_right = App.Vector(width + offset_h, 0 + offset_v, 0)
        upper_right = App.Vector(width + offset_h, height + offset_v, 0)

        return lower_left, upper_left, lower_right, upper_right


Box()
