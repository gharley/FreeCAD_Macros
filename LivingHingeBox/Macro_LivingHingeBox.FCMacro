__title__ = "living hinge box"
__author__ = "Greg Harley"
__version__ = "01.00"
__date__ = "1/21/21"

__Comment__ = "This macro creates a sketch of a living hinge box which can then be saved to a DXF file."

from enum import Enum
from typing import Optional
from math import radians, sqrt, acos, pi, ceil, floor

from PySide import QtCore, QtGui, QtSvg
from FreeCAD import Gui
import Part, PartDesign, Sketcher

# import Macro_LaserCutBox_rc

App = FreeCAD

# Indexes for geoid
START = 1
END = 2
ORIGIN = -1

# Indexes for box sides
TOP = 0
RIGHT = 1
BOTTOM = 2
LEFT = 3


# Directional enums for drawing edges
class Direction(Enum):
    NS = 1
    EW = 2
    SN = 3
    WE = 4


# Face enums for drawing edges
class Face(Enum):
    SIDE = 1
    END = 2
    BOTTOM = 3


class Hinge:
    DEFAULT_KERF = 0.2

    def __init__(self, sketch, height, thickness, radius, start_point=None, kerf=None):
        self.sketch = sketch
        self.height = height

        if start_point is None:
            start_point = App.Vector(0, height)
        self.start_point = start_point

        if kerf is None:
            kerf = Hinge.DEFAULT_KERF
        self.kerf = kerf

        self.upper_left = (start_point, 0)
        self.upper_right = None
        self.lower_right = None
        self.lower_left = None

        self.long_length = App.Vector(0, -(height - thickness * 2))
        self.long_line_index = -1
        self.short_length = self.long_length / 2
        self.short_line_index = -1
        self.gap_length_v = App.Vector(0, -(thickness * 2))
        self.gap_v_line_index = -1
        self.gap_size, self.num_segments = self.get_num_segments(radius, self.kerf)
        self.gap_length_h = App.Vector(self.gap_size, 0)
        self.gap_h_line_index = -1
        self.top_line_index = -1
        self.bottom_line_index = -1
        self.offset_line_index = -1

        self._outer_lines = []
        self._inner_lines = []

    @property
    def inner_lines(self): return self._inner_lines

    @property
    def outer_lines(self): return self._outer_lines

    @property
    def length(self): return self.gap_size * self.num_segments

    @property
    def start_point(self): return self._start_point

    @start_point.setter
    def start_point(self, value): self._start_point = value

    def add_line(self, start_point, end_offset, lines, connection=None):
        end_point = start_point + end_offset
        new_line = Part.LineSegment(start_point, end_point)
        index = self.sketch.addGeometry(new_line, False)

        if len(lines) != 0 and connection is None:
            connection = lines[-1], END

        if connection is not None:
            self.sketch.addConstraint(Sketcher.Constraint('Coincident', connection[0], connection[1], index, START))

        lines.append(index)

        return index, new_line

    def add_short_lines(self):
        start_point = self.start_point if len(self._outer_lines) == 0 else self.sketch.Geometry[self._outer_lines[-1]].EndPoint
        first_time = self.short_line_index == -1

        index, line = self.add_line(start_point, self.short_length, self._outer_lines)
        self.sketch.addConstraint(Sketcher.Constraint('Vertical', index))

        if first_time:
            self.short_line_index = index
            self.sketch.addConstraint(Sketcher.Constraint('DistanceY', index, self.short_length.y))
            self.sketch.addConstraint(Sketcher.Constraint('Coincident', self.short_line_index, START, self.top_line_index, START))
        else:
            self.sketch.addConstraint(Sketcher.Constraint('Equal', self.short_line_index, index))

        index, line = self.add_line(line.EndPoint, self.gap_length_v, self._outer_lines)
        self.sketch.addConstraint(Sketcher.Constraint('Vertical', index))
        self.sketch.toggleConstruction(index)

        if self.gap_v_line_index == -1:
            self.gap_v_line_index = index
            self.sketch.addConstraint(Sketcher.Constraint('DistanceY', index, self.gap_length_v.y))
        else:
            self.sketch.addConstraint(Sketcher.Constraint('Equal', self.gap_v_line_index, index))

        index, line = self.add_line(line.EndPoint, self.short_length, self._outer_lines)
        self.sketch.addConstraint(Sketcher.Constraint('Vertical', index))
        self.sketch.addConstraint(Sketcher.Constraint('Equal', self.short_line_index, index))

        if first_time:
            self.sketch.addConstraint(Sketcher.Constraint('Coincident', index, END, self.bottom_line_index, START))

        index, line = self.add_line(start_point, self.gap_length_h, self._outer_lines, (self._outer_lines[-3], START))
        self.sketch.addConstraint(Sketcher.Constraint('Horizontal', index))
        self.sketch.toggleConstruction(index)

        if self.gap_h_line_index == -1:
            self.gap_h_line_index = index
            self.sketch.addConstraint(Sketcher.Constraint('DistanceX', index, self.gap_length_h.x))
        else:
            self.sketch.addConstraint(Sketcher.Constraint('Equal', self.gap_h_line_index, index))

    def draw(self):
        hinge_length = App.Vector(self.length, 0)
        self.top_line_index = self.sketch.addGeometry(Part.LineSegment(self.start_point, self.start_point + hinge_length), False)
        self.sketch.addConstraint(Sketcher.Constraint('Horizontal', self.top_line_index))
        self.sketch.addConstraint(Sketcher.Constraint('DistanceX', self.top_line_index, self.length))

        hinge_height = App.Vector(0, self.height)
        self.bottom_line_index = self.sketch.addGeometry(Part.LineSegment(self.start_point + hinge_height, self.start_point + hinge_height + hinge_length), False)
        self.sketch.addConstraint(Sketcher.Constraint('Horizontal', self.bottom_line_index))
        self.sketch.addConstraint(Sketcher.Constraint('Equal', self.top_line_index, self.bottom_line_index))

        self.offset_line_index = self.sketch.addGeometry(Part.LineSegment(self.start_point + self.gap_length_v / 2, self.start_point + self.gap_length_v / 2 + hinge_length), False)
        self.sketch.addConstraint(Sketcher.Constraint('Horizontal', self.offset_line_index))
        self.sketch.addConstraint(Sketcher.Constraint('Equal', self.top_line_index, self.offset_line_index))
        self.sketch.addConstraint(Sketcher.Constraint('DistanceY', self.top_line_index, START, self.offset_line_index, START, self.gap_length_v.y / 2))
        self.sketch.toggleConstruction(self.offset_line_index)

        for idx in range(0, self.num_segments):
            self.add_short_lines()
            if idx == 0:
                self.upper_left = (self.start_point, self._outer_lines[0])

                index = self._outer_lines[2]
                self.lower_left = (self.get_line_from_index(index).EndPoint, index)

            line_index, inner_line = self.add_line(self.get_line_from_index(self._outer_lines[-1]).EndPoint - (self.gap_length_v / 2), self.long_length, self._inner_lines)
            self.sketch.addConstraint(Sketcher.Constraint('Vertical', line_index))

            if idx == 0:
                self.long_line_index = line_index
                self.sketch.addConstraint(Sketcher.Constraint('DistanceY', line_index, self.long_length.y))
                self.sketch.addConstraint(Sketcher.Constraint('Coincident', self.long_line_index, START, self.offset_line_index, START))
                self.sketch.addConstraint(Sketcher.Constraint('DistanceX', self.short_line_index, START, line_index, START, self.gap_size / 2))
            else:
                self.sketch.addConstraint(Sketcher.Constraint('Equal', self.long_line_index, line_index))

            line_index, inner_line = self.add_line(inner_line.EndPoint, self.gap_length_h, self._inner_lines, (line_index, START))
            self.sketch.addConstraint(Sketcher.Constraint('Horizontal', line_index))
            self.sketch.addConstraint(Sketcher.Constraint('Equal', self.gap_h_line_index, line_index))
            self.sketch.toggleConstruction(line_index)

        self.add_short_lines()

        self.upper_right = self.get_line_from_index(self._outer_lines[-4]).StartPoint, self._outer_lines[-4]
        self.lower_right = self.get_line_from_index(self._outer_lines[-2]).EndPoint, self._outer_lines[-2]

    def get_line_from_index(self, index):
        return self.sketch.Geometry[index]

    @staticmethod
    def get_num_segments(radius, kerf):
        # Totally arbitrary values based on T&E
        gap_size = 4
        length = radius * 2 * pi / 4
        return gap_size, ceil(length / (gap_size - kerf * 2))

    @staticmethod
    def calculate_length(radius, kerf=None):
        if kerf is None:
            kerf = Hinge.DEFAULT_KERF
        gap_size, num_segments = Hinge.get_num_segments(radius, kerf)
        return num_segments * gap_size


class Box:
    def __init__(self):
        if not App.ActiveDocument:
            App.newDocument()

        self.macro_dir = App.getUserMacroDir()

        self.dialog = Optional[QtGui.QWidget]
        self.image = Optional[QtGui.QLabel]
        self.widget = Optional[QtSvg.QSvgWidget]

        self.worksheet = None
        self.box_type = 0
        self.num_tabs = {'numTabsLength': 0, 'numTabsDepth': 0, 'numTabsHeight': 0}

        self._init_dialog()
        self.dialog.show()
        # self._update_image(0)
        self.dialog.exec_()

    # def _update_image(self, box_type):
    #     if not isinstance(self.widget, QtSvg.QSvgWidget):
    #         self.widget = QtSvg.QSvgWidget(self.dialog)
    #         self.widget.setGeometry(self.image.geometry())
    #
    #     if box_type == 0:
    #         self.widget.renderer().load(self.macro_dir + 'end_all.svg')
    #     elif box_type == 1:
    #         self.widget.renderer().load(self.macro_dir + 'end_slots.svg')
    #     else:
    #         self.widget.renderer().load(self.macro_dir + 'end_edge.svg')
    #
    #     self.widget.show()

    def _init_dialog(self):
        self.dialog = Gui.PySideUic.loadUi('{0}Macro_LivingHingeBox.ui'.format(self.macro_dir))
        self.dialog.setWindowTitle("Living hinge box")
        # self.image = self.dialog.findChild(QtGui.QLabel, 'image')

        QtCore.QObject.connect(self.dialog.buttonBox, QtCore.SIGNAL('accepted()'), self.build_geometry)
        # QtCore.QObject.connect(self.dialog.tabTypes, QtCore.SIGNAL('currentIndexChanged(int)'), self._update_image)

    def _init_sheet(self):
        self.worksheet = App.ActiveDocument.addObject('Spreadsheet::Sheet', 'Parameters')
        set_cell = self.worksheet.set

        def column_a(idx):
            return 'A' + str(idx)

        def column_b(idx):
            return 'B' + str(idx)

        self.worksheet.setColumnWidth('A', 150)

        index = 0
        for obj in self.dialog.findChildren(QtGui.QLabel):
            index += 1
            col_a = column_a(index)
            col_b = column_b(index)

            buddy = obj.buddy()
            if buddy is not None:
                buddy_name = buddy.objectName()

                if isinstance(buddy, QtGui.QComboBox):
                    self.box_type = buddy.currentIndex()
                    index -= 1
                else:
                    buddy_value = buddy.text()

                    if self.num_tabs.get(buddy_name) is not None:
                        self.num_tabs[buddy_name] = buddy_value
                        index -= 1
                    else:
                        set_cell(col_a, obj.text())
                        set_cell(col_b, buddy_value)
                        self.worksheet.setAlias(col_b, buddy_name)
            else:
                if obj.statusTip() == 'skip':
                    index -= 1
                else:
                    self.worksheet.setStyle(col_a, 'bold')
                    self.worksheet.setAlignment(col_a, 'center|vcenter')
                    self.worksheet.mergeCells(col_a + ':' + col_b)
                    set_cell(col_a, obj.text())

        App.ActiveDocument.recompute(None, True, True)

        if self.worksheet.bottomThickness == 0:
            self.worksheet.set(self.worksheet.getCellFromAlias('bottomThickness'), str(self.worksheet.thickness))

        if self.worksheet.lidThickness == 0:
            self.worksheet.set(self.worksheet.getCellFromAlias('lidThickness'), str(self.worksheet.thickness))

        col_a = column_a(index)
        self.worksheet.setStyle(col_a, 'bold')
        self.worksheet.setAlignment(col_a, 'center|vcenter')
        self.worksheet.mergeCells(col_a + ':' + column_b(index))
        set_cell(col_a, 'Calculated Values DO NOT EDIT')

        def set_calc(label, alias, formula):
            _col_b = column_b(index)
            set_cell(column_a(index), label)
            set_cell(_col_b, formula)
            self.worksheet.setAlias(_col_b, alias)

        index += 1
        num_tabs = int(self.num_tabs['numTabsLength'])
        formula = '=width - offsetH * 2 - tabWidth' if num_tabs == 1 else '=(width - offsetH * 2 - tabWidth * {0}) / ({0} - 1)'.format(num_tabs)
        set_calc('Side tab gap', 'sideGap', formula)

        index += 1
        num_tabs = int(self.num_tabs['numTabsDepth'])
        formula = '=depth - offsetH * 2 - tabWidth' if num_tabs == 1 else '=(depth - offsetH * 2 - tabWidth * {0}) / ({0} - 1)'.format(num_tabs)
        set_calc('End tab gap', 'endGap', formula)

        index += 1
        num_tabs = int(self.num_tabs['numTabsHeight'])
        formula = '=({0}) - offsetV * 2 - tabWidth' if num_tabs == 1 else '=(({0}) - offsetV * 2 - tabWidth * {1}) / ({1} - 1)'.format('{0}',
                                                                                                                                       num_tabs)

        if self.box_type == 0:
            set_calc('Height tab gap', 'heightGap', formula.format('height + lidThickness + bottomThickness * 2'))
        elif self.box_type == 1:
            set_calc('Height tab gap', 'heightGap', formula.format('height + lidThickness + bottomThickness'))
        else:
            set_calc('Height tab gap', 'heightGap', formula.format('height + bottomThickness'))

        App.ActiveDocument.recompute(None, True, True)

    def build_geometry(self):
        self._init_sheet()

        if self.dialog.chkSide.isChecked():
            self.build_long_side()
        #
        # if self.dialog.chkBottom.isChecked():
        #     self.build_bottom()

    def _build_side(self, sketch_name, width_alias, face, tab_func):
        sheet = self.worksheet
        sheet_prefix = self.get_sheet_expression_prefix()

        sketch = self._add_sketch(sketch_name)

        thickness = sheet.thickness
        width = sheet.width
        depth = sheet.depth
        height = sheet.height
        offset = sheet.offsetH

        bottom_thickness = sheet.bottomThickness
        lid_thickness = sheet.lidThickness

        if self.box_type == 0:
            actual_height = height + lid_thickness + bottom_thickness * 2
        elif self.box_type == 1:
            actual_height = height + lid_thickness + bottom_thickness
        else:
            actual_height = height + bottom_thickness

        def draw_lines(top_start, bottom_start, length):
            line1 = sketch.addGeometry(Part.LineSegment(top_start, top_start + length), False)
            sketch.addConstraint(Sketcher.Constraint('Horizontal', line1))
            sketch.addConstraint(Sketcher.Constraint('DistanceX', line1, length.x))

            line2 = sketch.addGeometry(Part.LineSegment(bottom_start, bottom_start + length), False)
            sketch.addConstraint(Sketcher.Constraint('Horizontal', line2))
            sketch.addConstraint(Sketcher.Constraint('Equal', line1, line2))

            return line1, line2

        def draw_side(top_start, bottom_start, length, old_hinge=None):
            top_line, bottom_line = draw_lines(top_start, bottom_start, length)
            if old_hinge is not None:
                sketch.addConstraint(Sketcher.Constraint('Coincident', top_line, START, old_hinge.upper_right[1], START))
                # sketch.addConstraint(Sketcher.Constraint('Coincident', bottom_line, START, old_hinge.lower_right[1], END))

            new_hinge = Hinge(sketch, actual_height, thickness, sheet.radius, top_start + length)
            new_hinge.draw()

            sketch.addConstraint(Sketcher.Constraint('Coincident', top_line, END, new_hinge.upper_left[1], START))
            sketch.addConstraint(Sketcher.Constraint('Coincident', bottom_line, END, new_hinge.lower_left[1], END))

            return new_hinge

        lower_left, upper_left, lower_right, upper_right = self.get_vectors(width, actual_height)
        hinge_length = Hinge.calculate_length(sheet.radius)
        short_length = App.Vector(depth - hinge_length, 0)
        long_length = App.Vector(width - hinge_length, 0)

        hinge = draw_side(upper_left, lower_left, short_length / 2)
        hinge = draw_side(hinge.upper_right[0], hinge.lower_right[0], long_length, hinge)
        hinge = draw_side(hinge.upper_right[0], hinge.lower_right[0], short_length, hinge)
        hinge = draw_side(hinge.upper_right[0], hinge.lower_right[0], long_length, hinge)
        # hinge = draw_side(hinge.upper_right[0], hinge.lower_right[0], short_length / 2, hinge)
        #
        # box = [[sketch.addGeometry(Part.LineSegment(upper_left, upper_right), False)]]
        #
        # lines = self.draw_edge_tabs(sketch, face, Direction.NS, True, upper_right)
        # box.append(lines)
        #
        # if self.box_type != 1:
        #     lines = self.draw_edge_tabs(sketch, face, Direction.EW, True, lower_left)
        # else:
        #     lines = [sketch.addGeometry(Part.LineSegment(lower_left, lower_right), False)]
        #
        # box.append(lines)
        #
        # lines = self.draw_edge_tabs(sketch, face, Direction.SN, False, upper_left)
        # box.append(lines)
        #
        # self._constrain_sides(sketch, box)
        #
        # sketch.addConstraint(Sketcher.Constraint('Horizontal', box[TOP][0]))
        # constraint = sketch.addConstraint(Sketcher.Constraint('DistanceX', box[TOP][0], actual_width))
        # sketch.setExpression("Constraints[{0}]".format(str(constraint)), width_expression)
        #
        # constraint = sketch.addConstraint(Sketcher.Constraint('DistanceY', box[LEFT][0], START, box[LEFT][-1], END, -actual_height))
        # sketch.setExpression("Constraints[{0}]".format(str(constraint)), height_expression)
        #
        # if self.box_type == 1:
        #     constraint = sketch.addConstraint(Sketcher.Constraint('DistanceY', box[RIGHT][0], START, box[RIGHT][-1], END, -actual_height))
        #     sketch.setExpression("Constraints[{0}]".format(str(constraint)), height_expression)
        #
        # sketch.movePoint(box[TOP][0], START, App.Vector(-actual_width / 2, actual_height / 2, 0))
        # sketch.addConstraint(Sketcher.Constraint('Symmetric', box[TOP][0], START, box[RIGHT][-1], END, ORIGIN, START))
        # App.ActiveDocument.recompute(None, True, True)
        #
        # if self.box_type != 2:
        #     tab = tab_func(sketch)
        #
        #     constraint = sketch.addConstraint(Sketcher.Constraint('DistanceX', box[TOP][0], START, tab[TOP][0], START, offset))
        #     sketch.setExpression("Constraints[{0}]".format(str(constraint)), '{0}offsetH'.format(sheet_prefix))
        #
        #     constraint = sketch.addConstraint(Sketcher.Constraint('DistanceY', tab[TOP][0], START, box[TOP][0], START, lid_thickness))
        #     sketch.setExpression("Constraints[{0}]".format(str(constraint)), '{0}lidThickness'.format(sheet_prefix))

        App.ActiveDocument.recompute(None, True, True)
        Gui.ActiveDocument.ActiveView.fitAll()

    def build_bottom(self):
        sheet = self.worksheet
        sheet_prefix = self.get_sheet_expression_prefix()

        sketch = self._add_sketch('BoxBottom')

        width = sheet.width
        width_expression = '{0}width'.format(sheet_prefix)

        depth = sheet.depth
        depth_expression = '-{0}depth'.format(sheet_prefix)

        lower_left, upper_left, lower_right, upper_right = self.get_vectors(width, depth)

        box = [self.draw_edge_tabs(sketch, Face.BOTTOM, Direction.WE, False, upper_left),
               self.draw_edge_tabs(sketch, Face.BOTTOM, Direction.NS, False, upper_right),
               self.draw_edge_tabs(sketch, Face.BOTTOM, Direction.EW, False, lower_left),
               self.draw_edge_tabs(sketch, Face.BOTTOM, Direction.SN, False, upper_left)]

        self._constrain_sides(sketch, box)

        constraint = sketch.addConstraint(Sketcher.Constraint('DistanceX', box[TOP][0], START, box[TOP][-1], END, width))
        sketch.setExpression("Constraints[{0}]".format(str(constraint)), width_expression)

        constraint = sketch.addConstraint(Sketcher.Constraint('DistanceY', box[LEFT][0], START, box[LEFT][-1], END, -depth))
        sketch.setExpression("Constraints[{0}]".format(str(constraint)), depth_expression)

        sketch.movePoint(box[TOP][0], START, App.Vector(-width / 2, depth / 2, 0))
        sketch.addConstraint(Sketcher.Constraint('Symmetric', box[TOP][0], START, box[RIGHT][-1], END, ORIGIN, START))

        App.ActiveDocument.recompute(None, True, True)
        Gui.ActiveDocument.ActiveView.fitAll()

    def build_long_side(self):
        self._build_side('BoxSide', 'width', Face.SIDE, self.draw_side_slots)

    def build_short_side(self):
        self._build_side('BoxEnd', 'depth', Face.END, self.draw_end_slots)

    def draw_slot(self, sketch, width, height, expression_h, expression_v):
        lower_left, upper_left, lower_right, upper_right = self.get_vectors(width, height)

        top = sketch.addGeometry(Part.LineSegment(upper_left, upper_right), False)
        right = sketch.addGeometry(Part.LineSegment(upper_right, lower_right), False)
        bottom = sketch.addGeometry(Part.LineSegment(lower_right, lower_left), False)
        left = sketch.addGeometry(Part.LineSegment(lower_left, upper_left), False)

        sketch.addConstraint(Sketcher.Constraint('Horizontal', top))
        sketch.addConstraint(Sketcher.Constraint('Vertical', left))
        sketch.addConstraint(Sketcher.Constraint('Vertical', right))

        sketch.addConstraint(Sketcher.Constraint('Equal', left, right))

        constraint = sketch.addConstraint(Sketcher.Constraint('DistanceX', top, width))
        sketch.setExpression("Constraints[{0}]".format(str(constraint)), expression_h)

        constraint = sketch.addConstraint(Sketcher.Constraint('DistanceY', left, height))
        sketch.setExpression("Constraints[{0}]".format(str(constraint)), expression_v)

        sketch.addConstraint(Sketcher.Constraint('Coincident', top, END, right, START))
        sketch.addConstraint(Sketcher.Constraint('Coincident', right, END, bottom, START))
        sketch.addConstraint(Sketcher.Constraint('Coincident', bottom, END, left, START))
        sketch.addConstraint(Sketcher.Constraint('Coincident', left, END, top, START))

        return [top, right, bottom, left]

    def _draw_slots(self, sketch, num_tabs, gap, expression_gap):
        tabs = []
        first = []
        tab_width = self.worksheet.tabWidth
        expression_width = '{0}tabWidth'.format(self.get_sheet_expression_prefix())
        bottom_thickness = self.worksheet.bottomThickness
        expression_thickness = '{0}bottomThickness'.format(self.get_sheet_expression_prefix())

        for idx in range(0, num_tabs):
            tab = self.draw_slot(sketch, tab_width, bottom_thickness, expression_width, expression_thickness)
            tabs.append(tab)

            if idx == 0:
                first = tab
            else:
                constraint = sketch.addConstraint(
                    Sketcher.Constraint('DistanceX', first[TOP], END, tab[TOP], START, gap * idx + tab_width * (idx - 1)))
                sketch.setExpression("Constraints[{0}]".format(str(constraint)), expression_gap.format(idx))

                sketch.addConstraint(Sketcher.Constraint('DistanceY', first[TOP], END, tab[TOP], START, 0))

        return tabs

    def draw_slots(self, sketch, num_tabs, gap_alias):
        sheet = self.worksheet
        sheet_prefix = self.get_sheet_expression_prefix()

        gap = sheet.get(sheet.getCellFromAlias(gap_alias))

        return self._draw_slots(sketch, num_tabs, gap, '{0}{1} * {2} + {0}tabWidth * ({2} - 1)'.format(sheet_prefix, gap_alias, '{0}'))

    def draw_end_slots(self, sketch):
        num_tabs = int(self.num_tabs['numTabsDepth'])

        return self.draw_slots(sketch, num_tabs, "endGap")

    def draw_side_slots(self, sketch):
        num_tabs = int(self.num_tabs['numTabsLength'])

        return self.draw_slots(sketch, num_tabs, "sideGap")

    def draw_edge_tabs(self, sketch, face, direction, is_inset, start=App.Vector(0, 0)):
        sheet = self.worksheet
        sheet_prefix = self.get_sheet_expression_prefix()
        is_vertical = direction is Direction.NS or direction is Direction.SN
        config = {'gap': 0, 'gap_expression': '', 'num_tabs': 0,
                  'offset': 0, 'offset_expression': '',
                  'thickness': 0, 'thickness_expression': '',
                  'tab_width': 0, 'tab_width_expression': ''}

        lines = []

        def add_line(start_point, end_offset, previous):
            end_point = start_point + end_offset
            new_line = Part.LineSegment(start_point, end_point)
            index = sketch.addGeometry(new_line, False)

            if previous != -1:
                sketch.addConstraint(Sketcher.Constraint('Coincident', previous, END, index, START))
                sketch.addConstraint(Sketcher.Constraint('Perpendicular', previous, index))

            lines.append(index)

            return index, new_line

        if is_vertical:
            config['tab_width'] = -sheet.tabWidth
            config['tab_width_expression'] = '-{0}tabWidth'.format(sheet_prefix)

            if face is Face.BOTTOM:
                config['num_tabs'] = self.num_tabs['numTabsDepth']
                config['gap'] = -sheet.endGap
                config['gap_expression'] = '-{0}endGap'.format(sheet_prefix)
                config['offset'] = -sheet.offsetH
                config['offset_expression'] = '-{0}offsetH'.format(sheet_prefix)
            else:
                config['num_tabs'] = self.num_tabs['numTabsHeight']
                config['gap'] = -sheet.heightGap
                config['gap_expression'] = '-{0}heightGap'.format(sheet_prefix)
                config['offset'] = -sheet.offsetV
                config['offset_expression'] = '-{0}offsetV'.format(sheet_prefix)

            config['thickness'] = sheet.thickness
            config['thickness_expression'] = '{0}thickness'.format(sheet_prefix)

            if (is_inset and direction == Direction.NS) or (not is_inset and direction == Direction.SN):
                config['thickness'] = -config['thickness']
                config['thickness_expression'] = '-' + config['thickness_expression']

            offset_length = App.Vector(0, config['offset'])
            gap_length = App.Vector(0, config['gap'])
            tab_length = App.Vector(0, config['tab_width'])
            thickness_length = App.Vector(config['thickness'], 0)
        else:
            config['tab_width'] = sheet.tabWidth
            config['tab_width_expression'] = '{0}tabWidth'.format(sheet_prefix)

            if face is Face.SIDE or face is Face.BOTTOM:
                config['num_tabs'] = self.num_tabs['numTabsLength']
                config['gap'] = sheet.sideGap
                config['gap_expression'] = '{0}sideGap'.format(sheet_prefix)
            else:
                config['num_tabs'] = self.num_tabs['numTabsDepth']
                config['gap'] = sheet.endGap
                config['gap_expression'] = '{0}endGap'.format(sheet_prefix)

            if face is Face.BOTTOM:
                config['thickness'] = sheet.thickness
                config['thickness_expression'] = '{0}thickness'.format(sheet_prefix)
                config['offset'] = sheet.offsetH
                config['offset_expression'] = '{0}offsetH'.format(sheet_prefix)
            else:
                config['thickness'] = sheet.bottomThickness
                config['thickness_expression'] = '{0}bottomThickness'.format(sheet_prefix)
                config['offset'] = sheet.offsetH + sheet.thickness
                config['offset_expression'] = '{0}offsetH + {0}thickness'.format(sheet_prefix)

            if (is_inset and direction == Direction.WE) or (not is_inset and direction == Direction.EW):
                config['thickness'] = -config['thickness']
                config['thickness_expression'] = '-' + config['thickness_expression']

            offset_length = App.Vector(config['offset'], 0)
            gap_length = App.Vector(config['gap'], 0)
            tab_length = App.Vector(config['tab_width'], 0)
            thickness_length = App.Vector(0, config['thickness'])

        gap_line_index = -1
        first_tab_index = -1
        offset_line_index = -1
        thickness_line_index = -1
        line_index = -1
        line = Optional[Part.LineSegment]

        for idx in range(0, int(config['num_tabs'])):
            if idx == 0:
                line_index, line = add_line(start, offset_length, line_index)

                offset_line_index = line_index
                if is_vertical:
                    sketch.addConstraint(Sketcher.Constraint('Vertical', offset_line_index))
                else:
                    sketch.addConstraint(Sketcher.Constraint('Horizontal', offset_line_index))
            else:
                line_index, line = add_line(line.EndPoint, gap_length, line_index)

                if gap_line_index == -1:
                    gap_line_index = line_index
                    constraint_type = 'DistanceY' if is_vertical else 'DistanceX'
                    constraint = sketch.addConstraint(Sketcher.Constraint(constraint_type, gap_line_index, config['gap']))
                    sketch.setExpression('Constraints[{0}]'.format(str(constraint)), config['gap_expression'])
                else:
                    sketch.addConstraint(Sketcher.Constraint('Equal', gap_line_index, line_index))

            line_index, line = add_line(line.EndPoint, thickness_length, line_index)

            if idx == 0:
                thickness_line_index = line_index
                constraint_type = 'DistanceX' if is_vertical else 'DistanceY'
                constraint = sketch.addConstraint(Sketcher.Constraint(constraint_type, thickness_line_index, config['thickness']))
                sketch.setExpression('Constraints[{0}]'.format(str(constraint)), config['thickness_expression'])
            else:
                sketch.addConstraint(Sketcher.Constraint('Equal', thickness_line_index, line_index))

            line_index, line = add_line(line.EndPoint, tab_length, line_index)

            if idx == 0:
                first_tab_index = line_index
                constraint_type = 'DistanceY' if is_vertical else 'DistanceX'
                constraint = sketch.addConstraint(Sketcher.Constraint(constraint_type, first_tab_index, config['tab_width']))
                sketch.setExpression('Constraints[{0}]'.format(str(constraint)), config['tab_width_expression'])
            else:
                sketch.addConstraint(Sketcher.Constraint('Equal', first_tab_index, line_index))

            line_index, line = add_line(line.EndPoint, -thickness_length, line_index)
            sketch.addConstraint(Sketcher.Constraint('Equal', thickness_line_index, line_index))

        line_index, line = add_line(line.EndPoint, offset_length, line_index)

        index = line_index if direction == Direction.NS or direction == Direction.EW else offset_line_index
        constraint_type = 'DistanceY' if is_vertical else 'DistanceX'
        constraint = sketch.addConstraint(Sketcher.Constraint(constraint_type, index, config['offset']))
        sketch.setExpression('Constraints[{0}]'.format(str(constraint)), config['offset_expression'])

        return lines

    # Helper methods
    def get_sheet_expression_prefix(self):
        return '<<' + self.worksheet.Name + '>>.'

    @staticmethod
    def _add_sketch(sketch_name):
        body = App.ActiveDocument.addObject('PartDesign::Body', sketch_name)
        sketch = App.ActiveDocument.addObject('Sketcher::SketchObject', sketch_name + 'Sketch')
        body.addObject(sketch)

        return sketch

    @staticmethod
    def _constrain_sides(sketch, box):
        sketch.addConstraint(Sketcher.Constraint('Coincident', box[TOP][0], START, box[LEFT][0], START))
        sketch.addConstraint(Sketcher.Constraint('Coincident', box[BOTTOM][-1], END, box[RIGHT][-1], END))
        sketch.addConstraint(Sketcher.Constraint('Coincident', box[TOP][-1], END, box[RIGHT][0], START))
        sketch.addConstraint(Sketcher.Constraint('Coincident', box[BOTTOM][0], START, box[LEFT][-1], END))

    @staticmethod
    def get_num_segments(thickness, radius, kerf=None):
        if kerf is None:
            kerf = 0.2

        rads = radians(radius)
        denom = (pi / 4 - (acos((kerf + thickness) / ((sqrt(pow(thickness, 2) / 2)) * 2))))
        num_segs = ceil(rads / denom)

        return num_segs

    @staticmethod
    def get_line(sketch, index):
        return sketch.Geometry[index]

    @staticmethod
    def get_line_length(sketch, line_array, is_vertical):
        start_line = sketch.Geometry[line_array[0]]
        end_line = sketch.Geometry[line_array[-1]]

        if is_vertical:
            length = end_line.EndPoint.y - start_line.StartPoint.y
        else:
            length = end_line.EndPoint.x - start_line.StartPoint.x

        return length

    @staticmethod
    def get_vectors(width, height):
        lower_left = App.Vector(0, 0, 0)
        upper_left = App.Vector(0, height, 0)
        lower_right = App.Vector(width, 0, 0)
        upper_right = App.Vector(width, height, 0)

        return lower_left, upper_left, lower_right, upper_right

    @staticmethod
    def log(message):
        App.Console.PrintMessage(str(message) + '\n')


Box()
