__title__ = "living hinge box"
__author__ = "Greg Harley"
__version__ = "01.00"
__date__ = "1/21/21"

__Comment__ = "This macro creates a sketch of a living hinge box which can then be saved to a DXF file."

from enum import Enum
from typing import Optional
from math import radians, sqrt, acos, pi, ceil, floor

from PySide import QtCore, QtGui, QtSvg
from FreeCAD import Gui
import Part, PartDesign, Sketcher

# import Macro_LaserCutBox_rc

App = FreeCAD


# Indexes for geoid
START = 1
END = 2
ORIGIN = -1

# Indexes for box sides
TOP = 0
RIGHT = 1
BOTTOM = 2
LEFT = 3


# Directional enums for drawing edges
class Direction(Enum):
    NS = 1
    EW = 2
    SN = 3
    WE = 4


# Face enums for drawing edges
class Face(Enum):
    SIDE = 1
    END = 2
    BOTTOM = 3


# dotdict - easy dictionary access
class DotDict(dict):
    """dot.notation access to dictionary attributes"""
    __getattr__ = dict.get
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__


class Hinge:
    DEFAULT_KERF = 0.2

    def __init__(self, sketch, height, thickness, radius, start_point=None, kerf=None, constrain=False):
        self.sketch = sketch
        self.constrain = constrain
        self.height = height
        self.thickness = thickness

        if start_point is None:
            start_point = App.Vector(0, 0)
        self.start_point = start_point

        if kerf is None:
            kerf = Hinge.DEFAULT_KERF
        self.kerf = kerf

        self.long_line_index = -1
        self.short_line_index = -1
        self.gap_v_line_index = -1
        self.gap_h_line_index = -1
        self.top_line_index = -1
        self.bottom_line_index = -1
        self.offset_line_index = -1

        self.gap_size, self.num_segments = self.get_num_segments(radius, self.kerf)

        self._outer_lines = []
        self._inner_lines = []

    @property
    def inner_lines(self): return self._inner_lines

    @property
    def outer_lines(self): return self._outer_lines

    @property
    def length(self): return self.gap_size * self.num_segments

    @property
    def start_point(self): return self._start_point

    @start_point.setter
    def start_point(self, value): self._start_point = value

    def add_line(self, start_point, end_offset, lines, connection=None):
        end_point = start_point + end_offset
        new_line = Part.LineSegment(start_point, end_point)
        index = self.sketch.addGeometry(new_line, False)

        if len(lines) != 0 and connection is None:
            connection = lines[-1], END

        if self.constrain and connection is not None:
            self.sketch.addConstraint(Sketcher.Constraint('Coincident', connection[0], connection[1], index, START))

        lines.append(index)

        return index, new_line

    def add_short_lines(self, short_length, gap_length_v, gap_length_h):
        first_time = self.short_line_index == -1
        start_point = self.start_point if first_time else self.sketch.Geometry[self._outer_lines[-1]].EndPoint

        index, line = self.add_line(start_point, short_length, self._outer_lines)
        if self.constrain:
            self.sketch.addConstraint(Sketcher.Constraint('Vertical', index))

        if first_time:
            self.short_line_index = index
            if self.constrain:
                self.sketch.addConstraint(Sketcher.Constraint('DistanceY', index, short_length.y))
                self.sketch.addConstraint(Sketcher.Constraint('Coincident', self.bottom_line_index, START, self.short_line_index, START))
        elif self.constrain:
            self.sketch.addConstraint(Sketcher.Constraint('Equal', self.short_line_index, index))

        index, line = self.add_line(line.EndPoint, gap_length_v, self._outer_lines)
        if self.constrain:
            self.sketch.addConstraint(Sketcher.Constraint('Vertical', index))
        self.sketch.toggleConstruction(index)

        if self.gap_v_line_index == -1:
            self.gap_v_line_index = index
        elif self.constrain:
            self.sketch.addConstraint(Sketcher.Constraint('Equal', self.gap_v_line_index, index))

        index, line = self.add_line(line.EndPoint, short_length, self._outer_lines)
        if self.constrain:
            self.sketch.addConstraint(Sketcher.Constraint('Vertical', index))
            self.sketch.addConstraint(Sketcher.Constraint('Equal', self.short_line_index, index))

        if self.constrain and first_time:
            self.sketch.addConstraint(Sketcher.Constraint('Coincident', self.top_line_index, START, index, END))

        index, line = self.add_line(start_point, gap_length_h, self._outer_lines, (self._outer_lines[-3], START))
        if self.constrain:
            self.sketch.addConstraint(Sketcher.Constraint('Horizontal', index))
        self.sketch.toggleConstruction(index)

        if self.gap_h_line_index == -1:
            self.gap_h_line_index = index
            if self.constrain:
                self.sketch.addConstraint(Sketcher.Constraint('DistanceX', index, gap_length_h.x))
        elif self.constrain:
            self.sketch.addConstraint(Sketcher.Constraint('Equal', self.gap_h_line_index, index))

    def draw(self):
        hinge_length = App.Vector(self.length, 0)
        hinge_height = App.Vector(0, self.height)
        long_length = App.Vector(0, self.height - self.thickness * 2)
        gap_length_v = App.Vector(0, self.thickness * 2)
        gap_length_h = App.Vector(self.gap_size, 0)

        self.bottom_line_index = self.sketch.addGeometry(Part.LineSegment(self.start_point, self.start_point + hinge_length), False)
        if self.constrain:
            self.sketch.addConstraint(Sketcher.Constraint('Horizontal', self.bottom_line_index))
            self.sketch.addConstraint(Sketcher.Constraint('DistanceX', self.bottom_line_index, hinge_length.x))

        self.top_line_index = self.sketch.addGeometry(Part.LineSegment(self.start_point + hinge_height, self.start_point + hinge_height + hinge_length), False)
        if self.constrain:
            self.sketch.addConstraint(Sketcher.Constraint('Horizontal', self.top_line_index))
            self.sketch.addConstraint(Sketcher.Constraint('Equal', self.bottom_line_index, self.top_line_index))
            self.sketch.addConstraint(Sketcher.Constraint('DistanceY', self.bottom_line_index, START, self.top_line_index, START, hinge_height.y))

        for idx in range(0, self.num_segments):
            self.add_short_lines(long_length / 2, gap_length_v, gap_length_h)

            long_start = self.get_line_from_index(self._outer_lines[-1]).EndPoint - (gap_length_h / 2) + (gap_length_v / 2)
            line_index, inner_line = self.add_line(long_start, long_length, self._inner_lines)
            if self.constrain:
                self.sketch.addConstraint(Sketcher.Constraint('Vertical', line_index))

            if idx == 0:
                self.long_line_index = line_index
                if self.constrain:
                    self.sketch.addConstraint(Sketcher.Constraint('DistanceY', line_index, long_length.y))
                    self.sketch.addConstraint(Sketcher.Constraint('DistanceY', self.short_line_index, START, line_index, START, gap_length_v.y / 2))
                    self.sketch.addConstraint(Sketcher.Constraint('DistanceX', self.short_line_index, START, line_index, START, gap_length_h.x / 2))
            elif self.constrain:
                self.sketch.addConstraint(Sketcher.Constraint('Equal', self.long_line_index, line_index))

            line_index, inner_line = self.add_line(long_start, gap_length_h, self._inner_lines, (self._inner_lines[-1], START))
            if self.constrain:
                self.sketch.addConstraint(Sketcher.Constraint('Horizontal', line_index))
                self.sketch.addConstraint(Sketcher.Constraint('Equal', self.gap_h_line_index, line_index))
            self.sketch.toggleConstruction(line_index)

        self.add_short_lines(long_length / 2, gap_length_v, gap_length_h)

    def get_line_from_index(self, index):
        return self.sketch.Geometry[index]

    @staticmethod
    def get_num_segments(radius, kerf):
        # Totally arbitrary values based on T&E
        gap_size = 4
        length = radius * 2 * pi / 4
        return gap_size, ceil(length / (gap_size - kerf * 2))

    @staticmethod
    def calculate_length(radius, kerf=None):
        if kerf is None:
            kerf = Hinge.DEFAULT_KERF
        gap_size, num_segments = Hinge.get_num_segments(radius, kerf)
        return num_segments * gap_size


class Box:
    def __init__(self):
        if not App.ActiveDocument:
            App.newDocument()

        self.macro_dir = App.getUserMacroDir()

        self.dialog = Optional[QtGui.QWidget]
        self.image = Optional[QtGui.QLabel]
        self.widget = Optional[QtSvg.QSvgWidget]

        self.props = DotDict()
        self.constrain = False
        self.box_type = 0

        self._init_dialog()
        self.dialog.show()
        # self._update_image(0)
        self.dialog.exec_()

    # def _update_image(self, box_type):
    #     if not isinstance(self.widget, QtSvg.QSvgWidget):
    #         self.widget = QtSvg.QSvgWidget(self.dialog)
    #         self.widget.setGeometry(self.image.geometry())
    #
    #     if box_type == 0:
    #         self.widget.renderer().load(self.macro_dir + 'end_all.svg')
    #     elif box_type == 1:
    #         self.widget.renderer().load(self.macro_dir + 'end_slots.svg')
    #     else:
    #         self.widget.renderer().load(self.macro_dir + 'end_edge.svg')
    #
    #     self.widget.show()

    def _init_dialog(self):
        self.dialog = Gui.PySideUic.loadUi('{0}Macro_LivingHingeBox.ui'.format(self.macro_dir))
        self.dialog.setWindowTitle("Living hinge box")
        # self.image = self.dialog.findChild(QtGui.QLabel, 'image')

        QtCore.QObject.connect(self.dialog.buttonBox, QtCore.SIGNAL('accepted()'), self.build_geometry)
        # QtCore.QObject.connect(self.dialog.tabTypes, QtCore.SIGNAL('currentIndexChanged(int)'), self._update_image)

    def _init_properties(self):
        for obj in self.dialog.findChildren(QtGui.QLabel):
            buddy = obj.buddy()
            if buddy is not None:
                buddy_name = buddy.objectName()

                if isinstance(buddy, QtGui.QComboBox):
                    self.box_type = buddy.currentIndex()
                else:
                    self.props[buddy_name] = float(buddy.text())

        if self.props.bottomThickness == 0:
            self.props.bottomThickness = self.props.thickness

        if self.props.lidThickness == 0:
            self.props.lidThickness = self.props.thickness

    def build_geometry(self):
        self._init_properties()

        self.constrain = self.dialog.chkConstrain.isChecked()

        if self.dialog.chkSide.isChecked():
            self.build_side()
        #
        # if self.dialog.chkBottom.isChecked():
        #     self.build_bottom()

    def build_side(self):
        props = self.props

        sketch = self._add_sketch('BoxSide')

        thickness = props.thickness
        width = props.width
        depth = props.depth
        height = props.height
        bottom_thickness = props.bottomThickness
        lid_thickness = props.lidThickness

        if self.box_type == 0:
            actual_height = height + lid_thickness + bottom_thickness * 2
        elif self.box_type == 1:
            actual_height = height + lid_thickness + bottom_thickness
        else:
            actual_height = height + bottom_thickness

        def draw_lines(top_start, bottom_start, length, num_tabs=1):
            line1 = sketch.addGeometry(Part.LineSegment(top_start, top_start + length), False)

            if self.box_type == 1:
                line2 = [sketch.addGeometry(Part.LineSegment(bottom_start, bottom_start + length), False)]
            else:
                line2 = self.draw_edge_tabs(sketch, num_tabs, length.x, Direction.WE, False, bottom_start)

            if self.constrain:
                sketch.addConstraint(Sketcher.Constraint('Horizontal', line1))
                sketch.addConstraint(Sketcher.Constraint('Horizontal', line2[0]))
                sketch.addConstraint(Sketcher.Constraint('DistanceX', line1, length.x))

                if self.box_type == 2:
                    sketch.addConstraint(Sketcher.Constraint('Equal', line1, line2[0]))

            return line1, line2

        def draw_side(top_start, bottom_start, length, num_tabs=1, old_hinge=None):
            top_line, bottom_line = draw_lines(top_start, bottom_start, length, num_tabs)
            if self.constrain and old_hinge is not None:
                sketch.addConstraint(Sketcher.Constraint('Coincident', old_hinge.top_line_index, END, top_line, START))

            if self.box_type != 2:
                slots = self.draw_slots(sketch, num_tabs, length.x, top_start)
                if self.constrain:
                    gap = (length.x - props.tabWidth * num_tabs) / (num_tabs + 1)
                    sketch.addConstraint(Sketcher.Constraint('DistanceX', top_line, START, slots[0][TOP], START, gap))
                    sketch.addConstraint(Sketcher.Constraint('DistanceY', top_line, START, slots[0][TOP], START, -props.lidThickness))

            new_hinge = Hinge(sketch, actual_height, thickness, props.radius, bottom_start + length, constrain=self.constrain)
            new_hinge.draw()

            if self.constrain:
                sketch.addConstraint(Sketcher.Constraint('Coincident', top_line, END, new_hinge.top_line_index, START))
                sketch.addConstraint(Sketcher.Constraint('Coincident', bottom_line[-1], END, new_hinge.bottom_line_index, START))

            top = new_hinge.get_line_from_index(new_hinge.top_line_index).EndPoint
            bottom = new_hinge.get_line_from_index(new_hinge.bottom_line_index).EndPoint

            return new_hinge, top, bottom

        lower_left, upper_left, lower_right, upper_right = self.get_vectors(width, actual_height)
        hinge_length = Hinge.calculate_length(props.radius)
        short_length = App.Vector(depth - hinge_length, 0)
        long_length = App.Vector(width - hinge_length, 0)

        hinge, first_top, hinge_bottom = draw_side(upper_left, lower_left, short_length / 2)
        hinge, hinge_top, hinge_bottom = draw_side(first_top, hinge_bottom, long_length, 4, hinge)
        hinge, hinge_top, hinge_bottom = draw_side(hinge_top, hinge_bottom, short_length, 4, hinge)
        hinge, hinge_top, hinge_bottom = draw_side(hinge_top, hinge_bottom, long_length, 4, hinge)

        last_top, last_bottom = draw_lines(hinge_top, hinge_bottom, short_length / 2)

        if self.box_type != 2:
            self.draw_slots(sketch, 1, short_length.x / 2, hinge_top)

        if self.constrain:
            sketch.addConstraint(Sketcher.Constraint('Coincident', hinge.top_line_index, END, last_top, START))
            sketch.addConstraint(Sketcher.Constraint('Coincident', hinge.bottom_line_index, END, last_bottom[-1], START))

        # if self.constrain:
        #     sketch.addConstraint(Sketcher.Constraint('Symmetric', 0, START, len(sketch.Geometry) - 1, END, ORIGIN, START))

        App.ActiveDocument.recompute(None, True, True)
        Gui.ActiveDocument.ActiveView.fitAll()

    def build_bottom(self):
        props = self.props
        sketch = self._add_sketch('BoxBottom')

        width = props.width
        depth = props.depth

        lower_left, upper_left, lower_right, upper_right = self.get_vectors(width, depth)

        box = [self.draw_edge_tabs(sketch, Face.BOTTOM, Direction.WE, False, upper_left),
               self.draw_edge_tabs(sketch, Face.BOTTOM, Direction.NS, False, upper_right),
               self.draw_edge_tabs(sketch, Face.BOTTOM, Direction.EW, False, lower_left),
               self.draw_edge_tabs(sketch, Face.BOTTOM, Direction.SN, False, upper_left)]

        self._constrain_sides(sketch, box)

        constraint = sketch.addConstraint(Sketcher.Constraint('DistanceX', box[TOP][0], START, box[TOP][-1], END, width))
        sketch.setExpression("Constraints[{0}]".format(str(constraint)), width_expression)

        constraint = sketch.addConstraint(Sketcher.Constraint('DistanceY', box[LEFT][0], START, box[LEFT][-1], END, -depth))
        sketch.setExpression("Constraints[{0}]".format(str(constraint)), depth_expression)

        sketch.movePoint(box[TOP][0], START, App.Vector(-width / 2, depth / 2, 0))
        sketch.addConstraint(Sketcher.Constraint('Symmetric', box[TOP][0], START, box[RIGHT][-1], END, ORIGIN, START))

        App.ActiveDocument.recompute(None, True, True)
        Gui.ActiveDocument.ActiveView.fitAll()

    def draw_slot(self, sketch, width, height, start_point=None):
        if start_point is None:
            start_point = App.Vector(0, 0)
        lower_left, upper_left, lower_right, upper_right = self.get_vectors(width, height)

        top = sketch.addGeometry(Part.LineSegment(upper_left + start_point, upper_right + start_point), False)
        right = sketch.addGeometry(Part.LineSegment(lower_right + start_point, upper_right + start_point), False)
        bottom = sketch.addGeometry(Part.LineSegment(lower_left + start_point, lower_right + start_point), False)
        left = sketch.addGeometry(Part.LineSegment(lower_left + start_point, upper_left + start_point), False)

        box = [top, right, bottom, left]

        if self.constrain:
            sketch.addConstraint(Sketcher.Constraint('Horizontal', top))
            sketch.addConstraint(Sketcher.Constraint('Horizontal', bottom))
            sketch.addConstraint(Sketcher.Constraint('Vertical', left))
            sketch.addConstraint(Sketcher.Constraint('Vertical', right))

            sketch.addConstraint(Sketcher.Constraint('Coincident', top, END, right, END))
            sketch.addConstraint(Sketcher.Constraint('Coincident', right, START, bottom, END))
            sketch.addConstraint(Sketcher.Constraint('Coincident', bottom, START, left, START))
            sketch.addConstraint(Sketcher.Constraint('Coincident', left, END, top, START))

            sketch.addConstraint(Sketcher.Constraint('DistanceY', left, height))
            sketch.addConstraint(Sketcher.Constraint('DistanceX', top, width))

        return box

    def draw_slots(self, sketch, num_tabs, width, start_point):
        if start_point is None:
            start_point = App.Vector(0, 0)

        tabs = []
        first = []
        tab_width = self.props.tabWidth
        gap = (width - num_tabs * tab_width) / (num_tabs + 1)
        bottom_thickness = self.props.bottomThickness
        offset_length = App.Vector(tab_width + gap, 0)
        start_point = start_point + App.Vector(gap, -(self.props.lidThickness + bottom_thickness))

        for idx in range(0, num_tabs):
            tab = self.draw_slot(sketch, tab_width, bottom_thickness, start_point + offset_length * idx)
            tabs.append(tab)

            if idx == 0:
                first = tab
            elif self.constrain:
                sketch.addConstraint(Sketcher.Constraint('DistanceX', first[TOP], END, tab[TOP], START, offset_length.x * idx))
                sketch.addConstraint(Sketcher.Constraint('DistanceY', first[TOP], END, tab[TOP], START, 0))

        return tabs

    def draw_edge_tabs(self, sketch, num_tabs, width, direction, is_bottom, start=App.Vector(0, 0)):
        props = self.props
        is_vertical = direction is Direction.NS or direction is Direction.SN
        config = DotDict({'num_tabs': num_tabs, 'tab_width': props.tabWidth})

        lines = []

        def add_line(start_point, end_offset, previous):
            end_point = start_point + end_offset
            new_line = Part.LineSegment(start_point, end_point)
            new_index = sketch.addGeometry(new_line, False)
            #
            # if self.constrain and previous != -1:
            #     sketch.addConstraint(Sketcher.Constraint('Coincident', previous, END, new_index, START))
            #     sketch.addConstraint(Sketcher.Constraint('Perpendicular', previous, new_index))

            lines.append(new_index)

            return new_index, new_line

        if is_vertical:
            config.tab_width = -props.tabWidth

            if is_bottom:
                config.num_tabs = props.numTabsDepth
                config.gap = -props.endGap
                config.offset = -props.offsetH
            else:
                config.num_tabs = props.numTabsHeight
                config.gap = -props.heightGap
                config.offset = -props.offsetV

            config.thickness = props.thickness

            if direction == Direction.SN:
                config.thickness = -config.thickness

            offset_length = App.Vector(0, config.offset)
            gap_length = App.Vector(0, config.gap)
            tab_length = App.Vector(0, config.tab_width)
            thickness_length = App.Vector(config.thickness, 0)
        else:
            config.gap = (width - num_tabs * config.tab_width) / (num_tabs + 1)
            config.offset = config.gap

            if is_bottom:
                config.thickness = props.thickness
            else:
                config.thickness = props.bottomThickness

            if (is_bottom and direction == Direction.WE) or (not is_bottom and direction == Direction.EW):
                config.thickness = -config.thickness

            offset_length = App.Vector(config.offset, 0)
            gap_length = App.Vector(config.gap, 0)
            tab_length = App.Vector(config.tab_width, 0)
            thickness_length = App.Vector(0, config.thickness)

        gap_line_index = -1
        first_tab_index = -1
        offset_line_index = -1
        thickness_line_index = -1
        line_index = -1
        line = Optional[Part.LineSegment]

        for idx in range(0, config.num_tabs):
            if idx == 0:
                line_index, line = add_line(start, offset_length, line_index)

                offset_line_index = line_index
                # if self.constrain:
                #     if is_vertical:
                #         sketch.addConstraint(Sketcher.Constraint('Vertical', offset_line_index))
                #     else:
                #         sketch.addConstraint(Sketcher.Constraint('Horizontal', offset_line_index))
            else:
                line_index, line = add_line(line.EndPoint, gap_length, line_index)

                if gap_line_index == -1:
                    gap_line_index = line_index
                #     if self.constrain:
                #         constraint_type = 'DistanceY' if is_vertical else 'DistanceX'
                #         sketch.addConstraint(Sketcher.Constraint(constraint_type, gap_line_index, config.gap))
                # elif self.constrain:
                #     sketch.addConstraint(Sketcher.Constraint('Equal', gap_line_index, line_index))

            line_index, line = add_line(line.EndPoint, thickness_length, line_index)

            if idx == 0:
                thickness_line_index = line_index
            #     if self.constrain:
            #         constraint_type = 'DistanceX' if is_vertical else 'DistanceY'
            #         sketch.addConstraint(Sketcher.Constraint(constraint_type, thickness_line_index, config.thickness))
            # elif self.constrain:
            #     sketch.addConstraint(Sketcher.Constraint('Equal', thickness_line_index, line_index))

            line_index, line = add_line(line.EndPoint, tab_length, line_index)

            if idx == 0:
                first_tab_index = line_index
            #     if self.constrain:
            #         constraint_type = 'DistanceY' if is_vertical else 'DistanceX'
            #         sketch.addConstraint(Sketcher.Constraint(constraint_type, first_tab_index, config.tab_width))
            # elif self.constrain:
            #     sketch.addConstraint(Sketcher.Constraint('Equal', first_tab_index, line_index))

            line_index, line = add_line(line.EndPoint, -thickness_length, line_index)
            # if self.constrain:
            #     sketch.addConstraint(Sketcher.Constraint('Equal', thickness_line_index, line_index))

        line_index, line = add_line(line.EndPoint, offset_length, line_index)

        # if self.constrain:
        #     index = line_index if direction == Direction.NS or direction == Direction.EW else offset_line_index
        #     constraint_type = 'DistanceY' if is_vertical else 'DistanceX'
        #     sketch.addConstraint(Sketcher.Constraint(constraint_type, index, config.offset))

        return lines

    @staticmethod
    def _add_sketch(sketch_name):
        body = App.ActiveDocument.addObject('PartDesign::Body', sketch_name)
        sketch = App.ActiveDocument.addObject('Sketcher::SketchObject', sketch_name + 'Sketch')
        body.addObject(sketch)

        return sketch

    @staticmethod
    def _constrain_sides(sketch, box):
        sketch.addConstraint(Sketcher.Constraint('Coincident', box[LEFT][0], START, box[TOP][0], START))
        sketch.addConstraint(Sketcher.Constraint('Coincident', box[TOP][-1], END, box[RIGHT][-1], END))
        sketch.addConstraint(Sketcher.Constraint('Coincident', box[RIGHT][-1], END, box[BOTTOM][-1], END))
        sketch.addConstraint(Sketcher.Constraint('Coincident', box[BOTTOM][0], START, box[LEFT][0], START))

    @staticmethod
    def get_num_segments(thickness, radius, kerf=None):
        if kerf is None:
            kerf = 0.2

        rads = radians(radius)
        denom = (pi / 4 - (acos((kerf + thickness) / ((sqrt(pow(thickness, 2) / 2)) * 2))))
        num_segs = ceil(rads / denom)

        return num_segs

    @staticmethod
    def get_line(sketch, index):
        return sketch.Geometry[index]

    @staticmethod
    def get_line_length(sketch, line_array, is_vertical):
        start_line = sketch.Geometry[line_array[0]]
        end_line = sketch.Geometry[line_array[-1]]

        if is_vertical:
            length = end_line.EndPoint.y - start_line.StartPoint.y
        else:
            length = end_line.EndPoint.x - start_line.StartPoint.x

        return length

    @staticmethod
    def get_vectors(width, height):
        lower_left = App.Vector(0, 0, 0)
        upper_left = App.Vector(0, height, 0)
        lower_right = App.Vector(width, 0, 0)
        upper_right = App.Vector(width, height, 0)

        return lower_left, upper_left, lower_right, upper_right

    @staticmethod
    def log(message):
        App.Console.PrintMessage(str(message) + '\n')


Box()
